---
title: "20 Evaluation"
output: html_document
date: "2023-07-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 20.1 Introduction

```{r}
library(rlang)
library(purrr)
```

## 20.2 Evaluation basics

```{r}
x <- 10
eval(expr(x))

y <- 2
eval(expr(x + y))
```

```{r}
eval(expr(x + y), env(x = 1000))
```

```{r}
eval(print(x + 1), env(x = 1000))
```

```{r}
eval(expr(print(x + 1)), env(x = 1000))
```

### 20.2.1 Application: `local()`

```{r, error = T}
# Clean up variables created earlier
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  x + y
})

foo

x

y
```

```{r, error = TRUE}
local2 <- function(expr) {
  env <- env(caller_env())
  eval(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y
})

foo

x

y
```

### 20.2.2 Application: `source()`

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}
```

```{r}
source3 <- function(file, env = parent.frame()) {
  lines <- parse(file)
  res <- eval(lines, envir = env)
  invisible(res)
}
```

### 20.2.3 Gotcha: `function()`

```{r}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
```

```{r}
lobstr::ast(f)
```


```{r}
f()
```

```{r}
attr(f, "srcref") <- NULL
f
```


```{r}
lobstr::ast(f)
```
### 20.2.4 Exercises

1. Carefully read the documentation for `source()`. What environment does it use by default? What if you supply `local = TRUE`? How do you provide a custom environment?

Uses global with local = FALSE. With TRUE is uses the environment in which source is called. Or you can provide an environment to local instead of T or F

2. Predict the results of the following lines of code:

```{r}
eval(expr(eval(expr(eval(expr(2 + 2))))))
# 4
eval(eval(expr(eval(expr(eval(expr(2 + 2)))))))
# 4
expr(eval(expr(eval(expr(eval(expr(2 + 2)))))))
# Since outer most call is expr
# eval(expr(eval(expr(eval(expr(2 + 2)))))))
```

3. Fill in the function bodies below to re-implement `get()` using `sym()` and `eval()`, and `assign()` using `sym()`, `expr()`, and `eval()`. Donâ€™t worry about the multiple ways of choosing an environment that `get()` and `assign()` support; assume that the user supplies it explicitly.

```{r}
new_get <- function(name, env) {
  eval(expr = sym(name), envir = env)
}
new_assign <- function(name, value, env){
  eval(expr = expr(!!sym(name) <- !!value), envir = env)
}

new_get("x", env = .GlobalEnv)

new_assign("a", value = 420, .GlobalEnv)
new_get("a", env = .GlobalEnv)
```


4. Modify `source2()` so it returns the result of every expression, not just the last one. Can you eliminate the for loop?

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}

source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- map(exprs, eval, env)

  invisible(res)
}
```


5. We can make `base::local()` slightly easier to understand by spreading out over multiple lines:

```{r}
local3 <- function(expr, envir = new.env()) {
  call <- substitute(eval(quote(expr), envir))
  eval(call, envir = parent.frame())
}
```

Explain how `local()` works in words. (Hint: you might want to `print(call)` to help understand what `substitute()` is doing, and read the documentation to remind yourself what environment `new.env()` will inherit from.)

First a call to eval because it's inside of substitute, then it substitutes and then evals the new call in the caller environment

## 20.3 Quosures

### 20.3.1 Creating

```{r}
foo <- function(x) enquo(x)
foo(a + b)
```

```{r}
quo(x + y + z)
```

```{r}
new_quosure(expr(x + y), env(x = 1, y = 10))
```

### 20.3.2 Evaluating

```{r}
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
```

### 20.3.3 Dots

```{r}
f <- function(...) {
  x <- 1
  g(..., f = x)
}
g <- function(...) {
  enquos(...)
}

x <- 0
qs <- f(global = x)
qs
```

```{r}
map_dbl(qs, eval_tidy)
```

### 20.3.4 Under the hood

```{r}
f <- ~runif(3)
str(f)
```

```{r}
q4 <- new_quosure(expr(x + y + z))
class(q4)
```

```{r}
is_call(q4)

q4[[1]]

q4[[2]]
```

```{r}
attr(q4, ".Environment")
```

```{r}
get_expr(q4)

get_env(q4)
```

### 20.3.5 Nested quosures

```{r}
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))

x <- expr(!!q2 + !!q3)
```

```{r}
eval_tidy(x)
```

```{r}
x
```

```{r}
expr_print(x)
```

### 20.3.6 Exercises

1. Predict what each of the following quosures will return if evaluated.

```{r}
q1 <- new_quosure(expr(x), env(x = 1))
q1
#> <quosure>
#> expr: ^x
#> env:  0x7fac62d19130

q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
#> <quosure>
#> expr: ^x + (^x)
#> env:  0x7fac62e35a98

q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
#> <quosure>
#> expr: ^x + (^x + (^x))
#> env:  0x7fac6302feb0
```

```{r}
eval_tidy(q1)
# 1
eval_tidy(q2)
#11
eval_tidy(q3)
#111
```
It's all nested shit

2. Write an `enenv()` function that captures the environment associated with an argument. (Hint: this should only require two function calls.)

```{r}
enenv <- function(x){
  get_env(enquo(x))
}

enenv(a)
```


## 20.4 Data masks