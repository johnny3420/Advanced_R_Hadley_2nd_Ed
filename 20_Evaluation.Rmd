---
title: "20 Evaluation"
output: html_document
date: "2023-07-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 20.1 Introduction

```{r}
library(rlang)
library(purrr)
```

## 20.2 Evaluation basics

```{r}
x <- 10
eval(expr(x))

y <- 2
eval(expr(x + y))
```

```{r}
eval(expr(x + y), env(x = 1000))
```

```{r}
eval(print(x + 1), env(x = 1000))
```

```{r}
eval(expr(print(x + 1)), env(x = 1000))
```

### 20.2.1 Application: `local()`

```{r, error = T}
# Clean up variables created earlier
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  x + y
})

foo

x

y
```

```{r, error = TRUE}
local2 <- function(expr) {
  env <- env(caller_env())
  eval(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y
})

foo

x

y
```

### 20.2.2 Application: `source()`

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}
```

```{r}
source3 <- function(file, env = parent.frame()) {
  lines <- parse(file)
  res <- eval(lines, envir = env)
  invisible(res)
}
```

### 20.2.3 Gotcha: `function()`

```{r}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
```

```{r}
lobstr::ast(f)
```


```{r}
f()
```

```{r}
attr(f, "srcref") <- NULL
f
```


```{r}
lobstr::ast(f)
```
### 20.2.4 Exercises

1. Carefully read the documentation for `source()`. What environment does it use by default? What if you supply `local = TRUE`? How do you provide a custom environment?

Uses global with local = FALSE. With TRUE is uses the environment in which source is called. Or you can provide an environment to local instead of T or F

2. Predict the results of the following lines of code:

```{r}
eval(expr(eval(expr(eval(expr(2 + 2))))))
# 4
eval(eval(expr(eval(expr(eval(expr(2 + 2)))))))
# 4
expr(eval(expr(eval(expr(eval(expr(2 + 2)))))))
# Since outer most call is expr
# eval(expr(eval(expr(eval(expr(2 + 2)))))))
```

3. Fill in the function bodies below to re-implement `get()` using `sym()` and `eval()`, and `assign()` using `sym()`, `expr()`, and `eval()`. Don’t worry about the multiple ways of choosing an environment that `get()` and `assign()` support; assume that the user supplies it explicitly.

```{r}
new_get <- function(name, env) {
  eval(expr = sym(name), envir = env)
}
new_assign <- function(name, value, env){
  eval(expr = expr(!!sym(name) <- !!value), envir = env)
}

new_get("x", env = .GlobalEnv)

new_assign("a", value = 420, .GlobalEnv)
new_get("a", env = .GlobalEnv)
```


4. Modify `source2()` so it returns the result of every expression, not just the last one. Can you eliminate the for loop?

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}

source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- map(exprs, eval, env)

  invisible(res)
}
```


5. We can make `base::local()` slightly easier to understand by spreading out over multiple lines:

```{r}
local3 <- function(expr, envir = new.env()) {
  call <- substitute(eval(quote(expr), envir))
  eval(call, envir = parent.frame())
}
```

Explain how `local()` works in words. (Hint: you might want to `print(call)` to help understand what `substitute()` is doing, and read the documentation to remind yourself what environment `new.env()` will inherit from.)

First a call to eval because it's inside of substitute, then it substitutes and then evals the new call in the caller environment

## 20.3 Quosures

### 20.3.1 Creating

```{r}
foo <- function(x) enquo(x)
foo(a + b)
```

```{r}
quo(x + y + z)
```

```{r}
new_quosure(expr(x + y), env(x = 1, y = 10))
```

### 20.3.2 Evaluating

```{r}
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
```

### 20.3.3 Dots

```{r}
f <- function(...) {
  x <- 1
  g(..., f = x)
}
g <- function(...) {
  enquos(...)
}

x <- 0
qs <- f(global = x)
qs
```

```{r}
map_dbl(qs, eval_tidy)
```

### 20.3.4 Under the hood

```{r}
f <- ~runif(3)
str(f)
```

```{r}
q4 <- new_quosure(expr(x + y + z))
class(q4)
```

```{r}
is_call(q4)

q4[[1]]

q4[[2]]
```

```{r}
attr(q4, ".Environment")
```

```{r}
get_expr(q4)

get_env(q4)
```

### 20.3.5 Nested quosures

```{r}
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))

x <- expr(!!q2 + !!q3)
```

```{r}
eval_tidy(x)
```

```{r}
x
```

```{r}
expr_print(x)
```

### 20.3.6 Exercises

1. Predict what each of the following quosures will return if evaluated.

```{r}
q1 <- new_quosure(expr(x), env(x = 1))
q1
#> <quosure>
#> expr: ^x
#> env:  0x7fac62d19130

q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
#> <quosure>
#> expr: ^x + (^x)
#> env:  0x7fac62e35a98

q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3
#> <quosure>
#> expr: ^x + (^x + (^x))
#> env:  0x7fac6302feb0
```

```{r}
eval_tidy(q1)
# 1
eval_tidy(q2)
#11
eval_tidy(q3)
#111
```
It's all nested shit

2. Write an `enenv()` function that captures the environment associated with an argument. (Hint: this should only require two function calls.)

```{r}
enenv <- function(x){
  get_env(enquo(x))
}

enenv(a)
```


## 20.4 Data masks
### 20.4.1 Basics

```{r}
q1 <- new_quosure(expr(x * y), env(x = 100))
df <- data.frame(y = 1:10)

eval_tidy(q1, df)
```

```{r}
with2 <- function(data, expr) {
  expr <- enquo(expr)
  eval_tidy(expr, data)
}
```

```{r}
x <- 100
with2(df, x * y)
```

```{r}
with3 <- function(data, expr) {
  expr <- substitute(expr)
  eval(expr, data, caller_env())
}
```

### 20.4.2 Pronouns

```{r}
with2(df, x)
```

```{r}
x <- 1
df <- data.frame(x = 2)

with2(df, .data$x)

with2(df, .env$x)
```

```{r, error=TRUE}
with2(df, .data$y)
```

### 20.4.3 Application: `subset()`

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))

# Shorthand for sample_df[sample_df$a >= 4, ]
subset(sample_df, a >= 4)


# Shorthand for sample_df[sample_df$b == sample_df$c, ]
subset(sample_df, b == c)
```

```{r}
subset2 <- function(data, rows) {
  rows <- enquo(rows)
  rows_val <- eval_tidy(rows, data)
  stopifnot(is.logical(rows_val))

  data[rows_val, , drop = FALSE]
}

subset2(sample_df, b == c)
```

### 20.4.4 Application: transform
```{r}
df <- data.frame(x = c(2, 3, 1), y = runif(3))
transform(df, x = -x, y2 = 2 * y)
```

```{r}
transform2 <- function(.data, ...) {
  dots <- enquos(...)

  for (i in seq_along(dots)) {
    name <- names(dots)[[i]]
    dot <- dots[[i]]

    .data[[name]] <- eval_tidy(dot, .data)
  }

  .data
}

transform2(df, x2 = x * 2, y = -y)
```

### 20.4.5 Application: `select()`

```{r}
df <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)
subset(df, select = b:d)
```

```{r}
vars <- as.list(set_names(seq_along(df), names(df)))
str(vars)
```

```{r}
select2 <- function(data, ...) {
  dots <- enquos(...)

  vars <- as.list(set_names(seq_along(data), names(data)))
  cols <- unlist(map(dots, eval_tidy, vars))

  data[, cols, drop = FALSE]
}
select2(df, b:d)
```

### 20.4.6 Exercises
1. Why did I use a for loop in transform2() instead of map()? Consider `transform2(df, x = x * 2, x = x * 2)`.

```{r, error=TRUE}
df <- data.frame(x = c(2, 3, 1), y = runif(3))
transform2 <- function(.data, ...) {
  dots <- enquos(...)

  for (i in seq_along(dots)) {
    name <- names(dots)[[i]]
    dot <- dots[[i]]

    .data[[name]] <- eval_tidy(dot, .data)
  }

  .data
}

transform2(df, x2 = x * 2, y = -y)
transform2(df, x = x * 2, x = x * 2)
transform2(df, x2 = x * 2, x3 = x2 * 2)

transform3 <- function(.data, ...) {
  dots <- enquos(...)
  map(dots, eval_tidy, .data)
}

transform3(df, x2 = x * 2, y = -y)
transform3(df, x = x * 2, x = x * 2)
transform3(df, x2 = x * 2, x3 = x2 * 2)
```

Each operation is done in order. This allows your changes to x to be used in the next call which uses x in the chain of transformations. map doesn't allow for this since each is handled independently

2. Here’s an alternative implementation of `subset2()`:

Compare and contrast `subset3()` to `subset2()`. What are its advantages and disadvantages?


```{r}
#Orignal
subset2 <- function(data, rows) {
  rows <- enquo(rows)
  rows_val <- eval_tidy(rows, data)
  stopifnot(is.logical(rows_val))

  data[rows_val, , drop = FALSE]
}

#New
subset3 <- function(data, rows) {
  rows <- enquo(rows)
  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)
}

df <- data.frame(x = 1:3)
subset2(df, x == 1)
subset3(df, x == 1)
```

Both work, definitely more error checking in the first function.

3. The following function implements the basics of `dplyr::arrange()`. Annotate each line with a comment explaining what it does. Can you explain why !!.na.last is strictly correct, but omitting the !! is unlikely to cause problems?

```{r}
arrange2 <- function(.df, ..., .na.last = TRUE) {
  args <- enquos(...) # get the arguments for ordering the rows

  order_call <- expr(order(!!!args, na.last = !!.na.last))

  ord <- eval_tidy(order_call, .df)
  stopifnot(length(ord) == nrow(.df))

  .df[ord, , drop = FALSE]
}
```

## 20.5 Using tidy evaluation

### 20.5.1 Quoting and unquoting
```{r}
resample <- function(df, n) {
  idx <- sample(nrow(df), n, replace = TRUE)
  df[idx, , drop = FALSE]
}
```

```{r, error=TRUE}
subsample <- function(df, cond, n = nrow(df)) {
  df <- subset2(df, cond)
  resample(df, n) # this n can
}
rm(x)
df <- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)
subsample(df, x == 1)
```

```{r}
subsample <- function(df, cond, n = nrow(df)) {
  cond <- enquo(cond)

  df <- subset2(df, !!cond)
  resample(df, n)
}

subsample(df, x == 1)
```

### 20.5.2 Handling ambiguity

```{r}
threshold_x <- function(df, val) {
  subset2(df, x >= val)
}
```

```{r}
x <- 10
no_x <- data.frame(y = 1:3)
threshold_x(no_x, 2)
```

```{r}
has_val <- data.frame(x = 1:3, val = 9:11)
threshold_x(has_val, 2)
```

```{r, error = TRUE}
threshold_x <- function(df, val) {
  subset2(df, .data$x >= .env$val)
}

x <- 10
threshold_x(no_x, 2)
#> Error: Column `x` not found in `.data`
threshold_x(has_val, 2)
```

```{r}
threshold_x <- function(df, val) {
  subset2(df, .data$x >= !!val)
}
```

### 20.5.3 Quoting and ambiguity

```{r}
threshold_var <- function(df, var, val) {
  var <- as_string(ensym(var))
  subset2(df, .data[[var]] >= !!val)
}

df <- data.frame(x = 1:10)
threshold_var(df, x, 8)
```

```{r}
threshold_expr <- function(df, expr, val) {
  expr <- enquo(expr)
  subset2(df, !!expr >= !!val)
}
```

### 20.5.4 Exercises

1. I’ve included an alternative implementation of `threshold_var()` below. What makes it different to the approach I used above? What makes it harder?

```{r}
threshold_var <- function(df, var, val) {
  var <- ensym(var)
  subset2(df, `$`(.data, !!var) >= !!val)
}
```

## 20.6 Base evaluation